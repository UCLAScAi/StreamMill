TO DO LIST.

====================
Summer 2011
====================
1) Fix the execution of UDAs so that even when the user specified an incorrect UDA, the system still works. 
   Status: [Resolved] -- Unit test: /StreamMill/testing/bad_uda_test.pl
2) Provide a few useful UDAs for the system, so that anyone can use them
   Status: [Resolved] -- Default user (smm) is made public and has a set of UDAs that other people can view but not delete.
3) Trace -- Provide the ability for the user to access the trace information through SMM client.
   Status: [Resolved] -- The user can access the readme information through the system, and when the UDA crashed, the readme will contain that information.

====================
Bug
====================
1. Bug: When defining a mining and aggregates, an error is generated 
   claiming that some table is undefined, even though the definition is there

   status: Seems to be working

1. Bug: Multiple aggregates. 

When multiple aggregates are used in one SELECT statement, and each
aggregate producing multiple returns, only partial results are
generated. The reason is results in the RETURN table are deleted after
TERMINATE is called, while it should keep the results for
backtracking. The bug is reported and identified by Andrea Chu.

2. Bug: No error message is returned in the following case where FROM
clause is missing.

	TABLE trie(...);

	SELECT trie.name
	WHERE trie.age=10;

3. close table opened within aggregate: omission of terminate statement will leave table opened after the termination of aggregate.
aggregate test(..):int{
	table to-be-close;
initialize:iterate:{
}
/* omission of terminate{} */
}

4. key sequence may cause problem.  i.e. 
table t(a int, b int) btree(b,a);   may not be valid.
check transCursorGet2C() in trans2C.cc

5. Conflict between C Keywords, variables used by the user, and the
internal variables/function names generated by the compiler.

====================
Window Construct
====================
1. (Haixun) Compile each SQL statement in the input file into a separate C function.
Right now, the generated C code for a series SQL statement is concatenated
together in the main() function. This prevents us from supporting multiple
continuous queries.

Status: closed. 

2. We need to support comping source code in multiple files. We can call
each file a module, and we want to be able to call UDA/UDF defined in other
files, or use tables declared in other files.

3. Optimize the disk buffer access in atlaswin.cc. We use disk files to
hold the tuples in windows for a window query. Right now, everything is
done on disk, which can be slow, especially for most of the cases, the
window is small, and we can use memory of limited size to buffer disk
accesses.

4. (Richard) We need to come up with more test examples for the window construct. I
expect there must be quite a few bugs there.

5. (Richard) The support of time-based window. Right now, I only support count-based
window. The code has some place holders for time-based windows, and we need
to fill them.

6. (Richard) We need to support builtin aggregates (count, sum, avg, min, max) on
windows. We need to consider what are the tuples we need to hold in the
window -- e.g., we don't need to store every thing if we are just computing
min or max.

7. Window sharing. We need to detect if two windows are the same. We can
first work on sharing windows in a single query, and later, we need to
consider sharing windows and streams on different SQL statements.


====================
/sql TODO
====================
1. secondary index:
table(a int, b int) btree(a) btree(b);

2. UDA library


====================
RTREE Optimization
====================
1. Store pointer instead of block/record no.
Then we don't have to do multiplication for each I/O operation. (i.e. BLOCK_PTR = BLOCK_NO * BLOCK_SIZE)
The disadvantage is that we waste much space.

2. ChooseLeaf(): determine if enlarge==0 first, add heuristics when searching.
	See paper notes.
